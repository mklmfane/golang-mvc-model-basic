
```markdown
# Go + PostgreSQL + sqlc Example: MVC Architecture

This project is a demonstration of how to build a clean Go application using:

- **PostgreSQL** (running in Docker)
- **sqlc** (for type-safe, compile-time-checked database access)
- **MVC pattern** (separating your business logic into Models, Controllers, and Application entry)

It shows how to structure a Go project that connects to PostgreSQL, manages schema migrations, and separates concerns via MVC.

---

## 📂 Project structure

```

.
├── db
│   ├── migrations               # SQL schema migrations (DDL)
│   │   └── 000001\_init\_schema.up.sql
│   └── query                     # sqlc query files (CRUD statements)
│       └── accounts\_bank.sql
├── docker-compose.yaml           # Spins up PostgreSQL database
├── go.mod / go.sum                # Go module definitions
├── internal
│   ├── controller
│   │   └── account\_controller.go  # Business logic (Controller layer)
│   └── model
│       ├── accounts\_bank.sql.go   # Generated by sqlc (Model layer)
│       ├── db.go
│       └── models.go
├── main.go                        # Application entry (View layer here)
├── main-no-mvc.go                 # (Optional) non-MVC single-file version
└── sqlc.yaml                      # sqlc configuration file

````

---

## 🐘 Database setup (PostgreSQL via Docker Compose)

We use `docker-compose.yaml` to run PostgreSQL 16 with the following credentials:

```yaml
services:
  db:
    image: postgres:16
    container_name: postgres_db
    restart: always
    environment:
      POSTGRES_USER: myuser
      POSTGRES_PASSWORD: mypassword
      POSTGRES_DB: mydatabase
    ports:
      - "0.0.0.0:5432:5432"
      - "[::]:5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
volumes:
  postgres_data:
````

To start the database, simply run:

```bash
docker-compose up -d
```

✅ This will make PostgreSQL available at:

* `localhost:5432` (IPv4)
* `[::1]:5432` (IPv6)

---

## 📝 SQL migrations & queries

* `db/migrations/000001_init_schema.up.sql` defines the initial schema, containing:

```sql
CREATE TABLE accounts_bank (
  id SERIAL PRIMARY KEY,
  full_name VARCHAR NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now()
);
```

* `db/query/accounts_bank.sql` defines your **CRUD operations** for `sqlc`:

```sql
-- name: CreateAccount :one
INSERT INTO accounts_bank (full_name) VALUES ($1)
RETURNING id, full_name, created_at;

-- name: GetAccount :one
SELECT id, full_name, created_at FROM accounts_bank WHERE id = $1;

-- name: UpdateAccount :one
UPDATE accounts_bank SET full_name = $2 WHERE id = $1
RETURNING id, full_name, created_at;

-- name: DeleteAccount :exec
DELETE FROM accounts_bank WHERE id = $1;
```

---

## ⚙️ sqlc for the Model layer

`sqlc` generates your type-safe Go database code.

Configuration in `sqlc.yaml`:

```yaml
version: "2"
sql:
  - engine: "postgresql"
    queries: "./db/query"
    schema: "./db/migrations"
    gen:
      go:
        package: "model"
        out: "./internal/model"
```

Generate Go code with:

```bash
sqlc generate
```

This creates:

* `internal/model/accounts_bank.sql.go`
* `internal/model/models.go`
* `internal/model/db.go`

which provide a `Queries` struct with methods like:

```go
q.CreateAccount(ctx, ...)
q.GetAccount(ctx, ...)
q.UpdateAccount(ctx, ...)
q.DeleteAccount(ctx, ...)
```

---

## 🏗️ MVC architecture in Go

### 🔹 Model

* Handled by the `internal/model` package.
* Entirely generated by `sqlc`.
* Handles raw database access.

### 🔸 Controller

* `internal/controller/account_controller.go` encapsulates business logic:

```go
account, err := c.queries.CreateAccount(ctx, "Alice Smith")
```

* It times operations, prints results, and hides DB details.

### 🔹 View (app entry)

* `main.go` serves as the View/controller entry point:

```go
accController := controller.NewAccountController(db)
accController.CreateAccount("Alice Smith")
accController.GetAccount(1)
accController.UpdateAccount(1, "Alice Johnson")
accController.DeleteAccount(1)
```

It also ensures the `accounts_bank` table exists on startup by running:

```go
func createTableIfNotExists(db *sql.DB) error {
	query := `CREATE TABLE IF NOT EXISTS accounts_bank (...);`
	_, err := db.Exec(query)
	return err
}
```

---

## 🚀 Running the app

1️⃣ Start PostgreSQL with Docker:

```bash
docker-compose up -d
```

2️⃣ Generate your Go code with `sqlc`:

```bash
sqlc generate
```

3️⃣ Run your Go application:

```bash
go run main.go
```

✅ This will connect to the database, create the `accounts_bank` table if missing, and perform CRUD operations.

---

## ✅ Summary

This project is a clean example of structuring Go projects with:

* 🐘 PostgreSQL in Docker
* 🔥 `sqlc` for zero-runtime-cost DB access
* 📚 MVC separation (Model via `sqlc`, Controller via custom Go package, App/entry via `main.go`)

---

## 📝 Credits

* [`sqlc`](https://github.com/sqlc-dev/sqlc)
* Based on ideas from:
  [Go Web MVC example on Medium](https://medium.com/@pulumati.priyank/go-web-programming-mvc-architecture-based-web-app-73efdb826aa1)

---

🎯 **Done.**


```
