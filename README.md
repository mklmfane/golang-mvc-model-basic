
```markdown
# Go + PostgreSQL + sqlc Example: MVC Architecture

This project is a demonstration of how to build a clean Go application using:

- **PostgreSQL** (running in Docker)
- **sqlc** (for type-safe, compile-time-checked database access)
- **MVC pattern** (separating your business logic into Models, Controllers, and Application entry)

It shows how to structure a Go project that connects to PostgreSQL, manages schema migrations, and separates concerns via MVC.

---

## ğŸ“‚ Project structure

```

.
â”œâ”€â”€ db
â”‚   â”œâ”€â”€ migrations               # SQL schema migrations (DDL)
â”‚   â”‚   â””â”€â”€ 000001\_init\_schema.up.sql
â”‚   â””â”€â”€ query                     # sqlc query files (CRUD statements)
â”‚       â””â”€â”€ accounts\_bank.sql
â”œâ”€â”€ docker-compose.yaml           # Spins up PostgreSQL database
â”œâ”€â”€ go.mod / go.sum                # Go module definitions
â”œâ”€â”€ internal
â”‚   â”œâ”€â”€ controller
â”‚   â”‚   â””â”€â”€ account\_controller.go  # Business logic (Controller layer)
â”‚   â””â”€â”€ model
â”‚       â”œâ”€â”€ accounts\_bank.sql.go   # Generated by sqlc (Model layer)
â”‚       â”œâ”€â”€ db.go
â”‚       â””â”€â”€ models.go
â”œâ”€â”€ main.go                        # Application entry (View layer here)
â”œâ”€â”€ main-no-mvc.go                 # (Optional) non-MVC single-file version
â””â”€â”€ sqlc.yaml                      # sqlc configuration file

````

---

## ğŸ˜ Database setup (PostgreSQL via Docker Compose)

We use `docker-compose.yaml` to run PostgreSQL 16 with the following credentials:

```yaml
services:
  db:
    image: postgres:16
    container_name: postgres_db
    restart: always
    environment:
      POSTGRES_USER: myuser
      POSTGRES_PASSWORD: mypassword
      POSTGRES_DB: mydatabase
    ports:
      - "0.0.0.0:5432:5432"
      - "[::]:5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
volumes:
  postgres_data:
````

To start the database, simply run:

```bash
docker-compose up -d
```

âœ… This will make PostgreSQL available at:

* `localhost:5432` (IPv4)
* `[::1]:5432` (IPv6)

---

## ğŸ“ SQL migrations & queries

* `db/migrations/000001_init_schema.up.sql` defines the initial schema, containing:

```sql
CREATE TABLE accounts_bank (
  id SERIAL PRIMARY KEY,
  full_name VARCHAR NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now()
);
```

* `db/query/accounts_bank.sql` defines your **CRUD operations** for `sqlc`:

```sql
-- name: CreateAccount :one
INSERT INTO accounts_bank (full_name) VALUES ($1)
RETURNING id, full_name, created_at;

-- name: GetAccount :one
SELECT id, full_name, created_at FROM accounts_bank WHERE id = $1;

-- name: UpdateAccount :one
UPDATE accounts_bank SET full_name = $2 WHERE id = $1
RETURNING id, full_name, created_at;

-- name: DeleteAccount :exec
DELETE FROM accounts_bank WHERE id = $1;
```

---

## âš™ï¸ sqlc for the Model layer

`sqlc` generates your type-safe Go database code.

Configuration in `sqlc.yaml`:

```yaml
version: "2"
sql:
  - engine: "postgresql"
    queries: "./db/query"
    schema: "./db/migrations"
    gen:
      go:
        package: "model"
        out: "./internal/model"
```

Generate Go code with:

```bash
sqlc generate
```

This creates:

* `internal/model/accounts_bank.sql.go`
* `internal/model/models.go`
* `internal/model/db.go`

which provide a `Queries` struct with methods like:

```go
q.CreateAccount(ctx, ...)
q.GetAccount(ctx, ...)
q.UpdateAccount(ctx, ...)
q.DeleteAccount(ctx, ...)
```

---

## ğŸ—ï¸ MVC architecture in Go

### ğŸ”¹ Model

* Handled by the `internal/model` package.
* Entirely generated by `sqlc`.
* Handles raw database access.

### ğŸ”¸ Controller

* `internal/controller/account_controller.go` encapsulates business logic:

```go
account, err := c.queries.CreateAccount(ctx, "Alice Smith")
```

* It times operations, prints results, and hides DB details.

### ğŸ”¹ View (app entry)

* `main.go` serves as the View/controller entry point:

```go
accController := controller.NewAccountController(db)
accController.CreateAccount("Alice Smith")
accController.GetAccount(1)
accController.UpdateAccount(1, "Alice Johnson")
accController.DeleteAccount(1)
```

It also ensures the `accounts_bank` table exists on startup by running:

```go
func createTableIfNotExists(db *sql.DB) error {
	query := `CREATE TABLE IF NOT EXISTS accounts_bank (...);`
	_, err := db.Exec(query)
	return err
}
```

---

## ğŸš€ Running the app

1ï¸âƒ£ Start PostgreSQL with Docker:

```bash
docker-compose up -d
```

2ï¸âƒ£ Generate your Go code with `sqlc`:

```bash
sqlc generate
```

3ï¸âƒ£ Run your Go application:

```bash
go run main.go
```

âœ… This will connect to the database, create the `accounts_bank` table if missing, and perform CRUD operations.

---

## âœ… Summary

This project is a clean example of structuring Go projects with:

* ğŸ˜ PostgreSQL in Docker
* ğŸ”¥ `sqlc` for zero-runtime-cost DB access
* ğŸ“š MVC separation (Model via `sqlc`, Controller via custom Go package, App/entry via `main.go`)

---

## ğŸ“ Credits

* [`sqlc`](https://github.com/sqlc-dev/sqlc)
* Based on ideas from:
  [Go Web MVC example on Medium](https://medium.com/@pulumati.priyank/go-web-programming-mvc-architecture-based-web-app-73efdb826aa1)

---

ğŸ¯ **Done.**


```
